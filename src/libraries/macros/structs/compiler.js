import schema from "./Example.struct.js"
import fs from "fs"

const COMPILER_ERROR = "(STRUCT_COMPILER_ERROR) "

function schemaTypeToTypescriptType(fieldName="x", type="notspecified") {
    if (typeof type !== "string") {
        throw new Error(`${COMPILER_ERROR}field type must be a string with either 'char', 'num', or 'bool'. Got type: ${typeof type}`)
    }
    switch(type) {
        case "num":
            return "number"
        case "bool":
            return "StructBool"
        case "char":
            return "Char"
        default:
            throw new Error(`${COMPILER_ERROR}field '${fieldName}' has incorrect type '${type}'`)
    }
}

function classifyFields(schema={}) {
    return Object.keys(schema).map((fieldName, index) => {
        const type = schema[fieldName]
        return { 
            name: fieldName,
            id: index,
            primitiveType: schemaTypeToTypescriptType(fieldName, type),
            type
        }
    })
}

const ENCODING_RESERVED_INDICES_COUNT = 4
// encoding indices 
const ENDCODING_INDICATOR_ONE_INDEX = 0 
const ENDCODING_INDICATOR_TWO_INDEX = 1
const STRUCT_SIZE_INDEX = 2
const LENGTH_INDEX = 3
// end

// these values are more or less arbitrary.
// only use to confirm that data structure
// was created by this compiler at runtime
const ENDCODING_INDICATOR_ONE_VALUE = 45538
const ENDCODING_INDICATOR_TWO_VALUE = 99900

const ENCODING_INFORMATION_MISSING = -1

function generateClassDefinition(name="Example", schema={}) {
    try {
        console.log("üî® generating struct array for", name)
        const fields = classifyFields(schema)
        console.log("\nstruct schema tokens:", fields)
        const typesUsed = []
        const charTypeExists = fields.find(meta => meta.type === "char")
        if (charTypeExists) {
            typesUsed.push("Char")
        }
        const boolTypeUsed = fields.find(meta => meta.type === "bool")
        if (boolTypeUsed) {
            typesUsed.push("StructBool")
        } 
        return `
/* generated by struct compiler */
// generated @ ${Date.now()} (unix timestamp)
//
// full schema:
// ${JSON.stringify(schema)}
import {${
    typesUsed.length < 1 ?
        "" :
        typesUsed.map(type => type + ",").join(" ") + " "
}ArrayOfStruct, isStructArray, fastAbsoluteValue} from "./primitives/index"

// this encoding is standard to all structs.
// const enum are used so that the typescript
// compiler can inline all of them at compile time
const enum StructEncoding {
    encodingReservedIndicesCount=${ENCODING_RESERVED_INDICES_COUNT},

    // all reserved indices for encoding 
    encodingPaddingOneIndex=${ENDCODING_INDICATOR_ONE_INDEX},
    encodingPaddingTwoIndex=${ENDCODING_INDICATOR_TWO_INDEX},
    structSizeIndex=${STRUCT_SIZE_INDEX},
    lengthIndex=${LENGTH_INDEX},

    // these values are more or less arbitrary.
    // only use to confirm that data structure
    // was created by this compiler at runtime
    encodingPaddingOneValue=${ENDCODING_INDICATOR_ONE_VALUE},
    encodingPaddingTwoValue=${ENDCODING_INDICATOR_TWO_VALUE},
    
    encodingInformationMissing=${ENCODING_INFORMATION_MISSING},
}

// encodings specific to the '${name}' struct
const enum ${name}Encoding {
    // struct size for '${name}' is ${fields.length}
    // corresponding to fields: ${
        fields.map(meta => `'${meta.name}',`).join(" ")
    }
    // defined in schema
    structSize=${fields.length},

    // offsets
${fields.map((meta, index) => `\t${meta.name}Offset = ${index}, // typeof ${meta.primitiveType}`).join("\n")}
}

const enum conversions {
    byteToFloat64Factor=4
}

export class ${name} implements ArrayOfStruct {
    // these are here for sanity checks.
    // not compiled away by typescript.
    // also not used at runtime.
    // can be used as debugging tool
    static readonly structSize = ${name}Encoding.structSize
${
    fields.map(meta => `\tstatic readonly ${meta.name}Offset = ${name}Encoding.${meta.name}Offset`).join("\n")
}
    
    static fromBuffer(buffer: ArrayBuffer | SharedArrayBuffer): ${name} {
        try {
            const array = new Float64Array(buffer)
            return ${name}.fromFloat64Array(array)
        } catch {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input buffer was not an array of struct. Encoding is incorrect")
        }
    }

    static fromFloat64Array(array: Float64Array): ${name} {
        const isCorrectlyEncoded = isStructArray(array)
        if (!isCorrectlyEncoded) {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input array was not an array of struct. Encoding is incorrect")
        }
        const structArray = new ${name}(0, false, true)
        structArray.setMemory(array)
        return structArray
    }

    private memory: Float64Array
    
    constructor(initialSize: number, shared: boolean, fromPayload: boolean) {
        if (fromPayload) {
            this.memory = new Float64Array()
        } else {
            const requestedMemorySize = fastAbsoluteValue(initialSize)
            const sizeOfOneStructInBytes = (${name}Encoding.structSize * conversions.byteToFloat64Factor) + (StructEncoding.encodingReservedIndicesCount * conversions.byteToFloat64Factor)
            const BufferClass = shared ? SharedArrayBuffer : ArrayBuffer
            const buffer = new BufferClass(sizeOfOneStructInBytes * requestedMemorySize)
            const memory = new Float64Array(buffer)
            
            // set encoding information
            memory[StructEncoding.encodingPaddingOneIndex] = StructEncoding.encodingPaddingOneValue
            memory[StructEncoding.encodingPaddingTwoIndex] = StructEncoding.encodingPaddingTwoValue
            memory[StructEncoding.structSizeIndex] = ${name}Encoding.structSize
            // end
            
            this.memory = memory
        }
    }

    set(index: number, ${fields.map(meta => `${meta.name}: ${meta.primitiveType},`).join(" ")}) {
        const i = fastAbsoluteValue(index)
        const trueIndex = i * ${name}Encoding.structSize
${
    fields
        .map(meta => `\t\tthis.memory[StructEncoding.encodingReservedIndicesCount + trueIndex + ${
            `${name}Encoding.${meta.name}Offset`
            }] = ${meta.type === "char" ? `${meta.name}.charCodeAt(0)` : meta.name}`
        )
        .join("\n")
}
    }
${
    fields.map(meta => {
        return `
    ${meta.name}Get(index: number): ${meta.primitiveType} {
        const i = fastAbsoluteValue(index)
        const trueIndex = i * ${name}Encoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + trueIndex + ${`${name}Encoding.${meta.name}Offset`}]
        return ${meta.type === "char" ? "String.fromCharCode(value) as Char" : "value as " + meta.primitiveType}
    }

    ${meta.name}Set(index: number, value: ${meta.primitiveType}) {
        const i = fastAbsoluteValue(index)
        const trueIndex = i * ${name}Encoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + trueIndex + ${`${name}Encoding.${meta.name}Offset`}] = ${
            meta.type === "char" ?
                "value.charCodeAt(0)" : "value"
        }
    }
`
    })
    .join("")
} 
    indexAsObject(index: number): {${
        fields.map(meta => `${meta.name}: ${meta.primitiveType},`).join(" ")
    }} {
        return {
${
    fields.map(meta => `\t\t\t${meta.name}: this.${meta.name}Get(index),`).join("\n")
}
        }
    }

    indexAsTypedArray(index: number): Float64Array {
        const i = fastAbsoluteValue(index)
        const trueIndex = i * ${name}Encoding.structSize
        const startIndex = StructEncoding.encodingReservedIndicesCount + trueIndex
        return this.memory.slice(startIndex, startIndex + ${name}Encoding.structSize)
    }

    indexAsArray(index: number): [${fields.map(meta => meta.primitiveType + ",").join(" ")}] {
        return [
${
    fields.map(meta => `\t\t\tthis.${meta.name}Get(index),`).join("\n")
}
        ]
    }

    isStructArray(): boolean {
        return isStructArray(this.memory)
    }

    // the number of indices an individual struct
    // takes in array
    // check compiler primitives for reference.
    structSize(): number {
        return this.memory[StructEncoding.structSizeIndex] || StructEncoding.encodingInformationMissing
    }

    // number of structs in array is stored in this array
    // check compiler primitives for reference.
    length(): number {
        return this.memory[StructEncoding.lengthIndex] || StructEncoding.encodingInformationMissing
    }

    getMemory(): Float64Array {
        return this.memory
    }

    setMemory(newMemory: Float64Array) {
        this.memory = newMemory
    }
}
/* struct compiler end */
`.trim()
    } catch(err) {
        throw err
    }
}

function generateStruct(name="Example", schema={}, options={filename: "Example.struct.js"}) {
    let definition = ""
    try {
        definition = generateClassDefinition(name, schema)
    } catch(err) {
        console.error(`Error creating class definition for class '${name}' from source file ${options.filename}. Compilation aborted, error log:`)
        console.error(err)
        return
    }
    return { definition, outputFile: `${name}.struct.ts` }
}

const name = "Example"

// compiler
const { definition, outputFile } = generateStruct(name, schema, {
    filename: "Example.struct.js"
})
// end

fs.writeFileSync(outputFile, definition)
console.log("\nüìÅ wrote struct array to", outputFile)