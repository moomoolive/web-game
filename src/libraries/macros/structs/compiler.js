import schema from "./Example.struct.js"
import fs from "fs"

const COMPILER_ERROR = "(STRUCT_COMPILER_ERROR) "

function schemaTypeToTypescriptType(fieldName="x", type="notspecified") {
    if (typeof type !== "string") {
        throw new Error(`${COMPILER_ERROR}field type must be a string with either 'char', 'num', or 'bool'. Got type: ${typeof type}`)
    }
    switch(type) {
        case "num":
            return "number"
        case "bool":
            return "StructBool"
        case "char":
            return "Char"
        default:
            throw new Error(`${COMPILER_ERROR}field '${fieldName}' has incorrect type '${type}'`)
    }
}

function classifyFields(schema={}) {
    return Object.keys(schema).map((fieldName, index) => {
        const type = schema[fieldName]
        return { 
            name: fieldName,
            id: index,
            primitiveType: schemaTypeToTypescriptType(fieldName, type),
            type
        }
    })
}

const ENCODING_RESERVED_INDICES_COUNT = 4
// encoding indices 
const ENDCODING_INDICATOR_ONE_INDEX = 0 
const ENDCODING_INDICATOR_TWO_INDEX = 1
const STRUCT_SIZE_INDEX = 2
const LENGTH_INDEX = 3
// end

// these values are more or less arbitrary.
// only use to confirm that data structure
// was created by this compiler at runtime
const ENDCODING_INDICATOR_ONE_VALUE = 45538
const ENDCODING_INDICATOR_TWO_VALUE = 99900

const ENCODING_INFORMATION_MISSING = -1

function generateClassDefinition(name="Example", schema={}) {
    try {
        console.log("🔨 generating struct array for", name)
        const fields = classifyFields(schema)
        console.log("\nstruct schema tokens:", fields)
        const typesUsed = []
        const charTypeExists = fields.find(meta => meta.type === "char")
        if (charTypeExists) {
            typesUsed.push("Char")
        }
        const boolTypeUsed = fields.find(meta => meta.type === "bool")
        if (boolTypeUsed) {
            typesUsed.push("StructBool")
        } 
        return `
/* generated by struct compiler */
// generated @ ${Date.now()} (unix timestamp)
//
// full schema:
// ${JSON.stringify(schema)}
import {${
    typesUsed.length < 1 ?
        "" :
        typesUsed.map(type => type + ",").join(" ") + " "
}ArrayOfStruct, isStructArray, fastAbsoluteValue} from "./primitives/index"

// this encoding is standard to all structs.
// const enum are used so that the typescript
// compiler can inline all of them at compile time
const enum StructEncoding {
    encodingReservedIndicesCount=${ENCODING_RESERVED_INDICES_COUNT},

    // all reserved indices for encoding 
    encodingPaddingOneIndex=${ENDCODING_INDICATOR_ONE_INDEX},
    encodingPaddingTwoIndex=${ENDCODING_INDICATOR_TWO_INDEX},
    structSizeIndex=${STRUCT_SIZE_INDEX},
    lengthIndex=${LENGTH_INDEX},

    // these values are more or less arbitrary.
    // only use to confirm that the data structure
    // was created by this compiler at runtime
    encodingPaddingOneValue=${ENDCODING_INDICATOR_ONE_VALUE},
    encodingPaddingTwoValue=${ENDCODING_INDICATOR_TWO_VALUE},
    
    encodingInformationMissing=${ENCODING_INFORMATION_MISSING},
}

// encodings specific to the '${name}' struct
const enum ${name}Encoding {
    // struct size for '${name}' is ${fields.length}
    // corresponding to fields: ${
        fields.map(meta => `'${meta.name}',`).join(" ")
    }
    // defined in schema
    structSize=${fields.length},

    // offsets
${fields.map((meta, index) => `\t${meta.name}Offset=${index}, // typeof ${meta.primitiveType}`).join("\n")}
}

const enum conversions {
    byteToFloat64Factor=4
}

export interface ${name}Object {
${fields.map(meta => `\t${meta.name}: ${meta.primitiveType}`).join("\n")}
}

export class ${name} implements ArrayOfStruct<${name}Object> {
    // these are here for sanity checks.
    // not compiled away by typescript.
    // also not used at runtime.
    // can be used as debugging tool
    static readonly structSize = ${name}Encoding.structSize
${
    fields.map(meta => `\tstatic readonly ${meta.name}Offset=${name}Encoding.${meta.name}Offset`).join("\n")
}
    
    static fromBuffer(buffer: ArrayBuffer | SharedArrayBuffer): ${name} {
        try {
            const array = new Float64Array(buffer)
            return ${name}.fromFloat64Array(array)
        } catch {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input buffer was not an array of struct. Encoding is incorrect")
        }
    }

    static fromFloat64Array(array: Float64Array): ${name} {
        const isCorrectlyEncoded = isStructArray(array)
        if (!isCorrectlyEncoded) {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input array was not an array of struct. Encoding is incorrect")
        }
        const structArray = new ${name}(0, false, true)
        structArray.setMemory(array)
        return structArray
    }

    private memory: Float64Array
    
    constructor(initialSize: number, shared: boolean, fromPayload: boolean) {
        if (fromPayload) {
            this.memory = new Float64Array()
        } else {
            const requestedMemorySize = fastAbsoluteValue(initialSize)
            const sizeOfOneStructInBytes = (${name}Encoding.structSize * conversions.byteToFloat64Factor) + (StructEncoding.encodingReservedIndicesCount * conversions.byteToFloat64Factor)
            const BufferClass = shared ? SharedArrayBuffer : ArrayBuffer
            const buffer = new BufferClass(sizeOfOneStructInBytes * requestedMemorySize)
            const memory = new Float64Array(buffer)
            
            // set encoding information
            memory[StructEncoding.encodingPaddingOneIndex] = StructEncoding.encodingPaddingOneValue
            memory[StructEncoding.encodingPaddingTwoIndex] = StructEncoding.encodingPaddingTwoValue
            memory[StructEncoding.structSizeIndex] = ${name}Encoding.structSize
            // end
            
            this.memory = memory
        }
    }
    
    // returns underlying memory for array
    getMemory(): Float64Array {
        return this.memory
    }

    // sets underlying memory of array from a TypedArray
    // WARNING: this is an unsafe operation. Make sure the typed
    // array you are using to overwrite with is a StructArray by 
    // using the "isStructArray" utility function.
    setMemory(newMemory: Float64Array) {
        this.memory = newMemory
    }

    // number of structs in array is stored in this array
    // check compiler primitives for reference.
    length(): number {
        return this.memory[StructEncoding.lengthIndex] || StructEncoding.encodingInformationMissing
    }

    // returns number of elements that can be added before
    // resize is needed
    capacity(): number {
        const rawMemory = this.memory.length - StructEncoding.encodingReservedIndicesCount
        return rawMemory / ${name}Encoding.structSize
    }

    /* array mutators */

    // sets a given index in array with inputted values
    // note: inputting an index greater than the length of array has no effect
    set(index: number, ${fields.map(meta => `${meta.name}: ${meta.primitiveType},`).join(" ")}) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ${name}Encoding.structSize
${
    fields
        .map(meta => `\t\tthis.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ${
            `${name}Encoding.${meta.name}Offset`
            }] = ${meta.type === "char" ? `${meta.name}.charCodeAt(0)` : meta.name}`
        )
        .join("\n")
}
    }

    // sets a given index in array with inputted values in an unsafe manner
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    // note: inputting an index greater than the length of array has no effect
    unsafeSet(index: number, ${fields.map(meta => `${meta.name}: ${meta.primitiveType},`).join(" ")}) {
        const indexOffset = index * ${name}Encoding.structSize
${
    fields
        .map(meta => `\t\tthis.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ${
            `${name}Encoding.${meta.name}Offset`
            }] = ${meta.type === "char" ? `${meta.name}.charCodeAt(0)` : meta.name}`
        )
        .join("\n")
}
    }

    // removes a given index from array
    // note: do not use if order of array matters
    // this method swaps last element and target element
    // then pops the last element. This is far more performant
    // than the typical array.splice
    // Also: if you want the element back
    // you must do this manually.
    splice(index: number) {
        const lastIndex = this.length() - 1
        // make sure operation is valid
        if (index > lastIndex) {
            return
        }
        if (lastIndex === index) {
            return this.pop()
        }
        // create temporary variables with last element's values
${
    fields.map(meta => `\t\tconst ${meta.name}Tmp = this.${meta.name}Get(lastIndex)`).join("\n")
}
        
        // swap last element with target index
        const safeIndex = fastAbsoluteValue(index)
        this.unsafeSet(lastIndex, ${fields.map(meta => "this." + meta.name + "Get(safeIndex)," ).join(" ")})
        this.unsafeSet(safeIndex, ${fields.map(meta => meta.name + "Tmp,").join(" ")})
        
        // now that target index is in last index, remove it
        this.pop()
    }

    // adds inputted struct at end of the array
    push(${fields.map(meta => `${meta.name}: ${meta.primitiveType},`).join(" ")}) {
        const index = this.length() * ${name}Encoding.structSize
${
    fields
        .map(meta => `\t\tthis.memory[StructEncoding.encodingReservedIndicesCount + index + ${
            `${name}Encoding.${meta.name}Offset`
            }] = ${meta.type === "char" ? `${meta.name}.charCodeAt(0)` : meta.name}`
        )
        .join("\n")
}        
        
        // increment length count
        this.memory[StructEncoding.lengthIndex]++
    }

    // removes the last element of array
    // note: if you want the element back
    // you must do this manually.
    pop() {
        if (this.length() < 1) {
            return
        }
        // decrement length count
        this.memory[StructEncoding.lengthIndex]--
    }
    /* array mutators end */

    /* struct property setters and getters */
${
    fields.map(meta => {
        return `
    // a getter method for '${meta.name}' property
    ${meta.name}Get(index: number): ${meta.primitiveType} {
        const indexOffset = index * ${name}Encoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ${name + "Encoding." + meta.name}Offset]
        return ${meta.type === "char" ? "String.fromCharCode(value) as Char" : "value as " + meta.primitiveType}
    }

    // a setter method for '${meta.name}' property
    ${meta.name}Set(index: number, value: ${meta.primitiveType}) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ${name}Encoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ${name + "Encoding." + meta.name}Offset] = ${
            meta.type === "char" ?
                "value.charCodeAt(0)" : "value"
        }
    }

    // an unsafe setter method for '${meta.name}' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    ${meta.name}UnsafeSet(index: number, value: ${meta.primitiveType}) {
        const indexOffset = index * ${name}Encoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ${name + "Encoding." + meta.name}Offset] = ${
            meta.type === "char" ?
                "value.charCodeAt(0)" : "value"
        }
    }
`
    })
    .join("")
}
    // return a given index as a TypedArray
    indexAsArray(index: number): Float64Array {
        const indexOffset = index * ${name}Encoding.structSize
        const startIndex = StructEncoding.encodingReservedIndicesCount + indexOffset
        return this.memory.slice(startIndex, startIndex + ${name}Encoding.structSize)
    }
    /* struct property setters and getters end */

    /* debugging tools */

    // return a given index as a JS object
    indexAsObject(index: number): ${name}Object {
        return {
${
    fields.map(meta => `\t\t\t${meta.name}: this.${meta.name}Get(index),`).join("\n")
}
        }
    }

    // a runtime check to verify that memory
    // hasn't been corrupted
    isStructArray(): boolean {
        return isStructArray(this.memory)
    }

    // the number of indices an individual struct takes in memory
    // check compiler primitives for reference.
    structSize(): number {
        return this.memory[StructEncoding.structSizeIndex] || StructEncoding.encodingInformationMissing
    }
    /* debugging tools end */
}
/* struct compiler end */
`.trim()
    } catch(err) {
        throw err
    }
}

function generateStruct(name="Example", schema={}, options={filename: "Example.struct.js"}) {
    let definition = ""
    try {
        definition = generateClassDefinition(name, schema)
    } catch(err) {
        console.error(`Error creating class definition for class '${name}' from source file ${options.filename}. Compilation aborted, error log:`)
        console.error(err)
        return
    }
    return { definition, outputFile: `${name}.struct.ts` }
}

const name = "Example"

// compiler
const { definition, outputFile } = generateStruct(name, schema, {
    filename: "Example.struct.js"
})
// end

fs.writeFileSync(outputFile, definition)
console.log("\n📁 wrote struct array to", outputFile)