/* generated by struct compiler */
// generated @ 1644345647217 (unix timestamp)
//
// full schema:
// {"x":"num","y":"num","z":"num","cool":"bool","name":"char"}
import {Char, StructBool, ArrayOfStruct, isStructArray, fastAbsoluteValue} from "./primitives/index"

// this encoding is standard to all structs.
// const enum are used so that the typescript
// compiler can inline all of them at compile time
const enum StructEncoding {
    encodingReservedIndicesCount=4,

    // all reserved indices for encoding 
    encodingPaddingOneIndex=0,
    encodingPaddingTwoIndex=1,
    structSizeIndex=2,
    lengthIndex=3,

    // these values are more or less arbitrary.
    // only use to confirm that the data structure
    // was created by this compiler at runtime
    encodingPaddingOneValue=45538,
    encodingPaddingTwoValue=99900,
    
    encodingInformationMissing=-1,
}

// encodings specific to the 'Example' struct
const enum ExampleEncoding {
    // struct size for 'Example' is 5
    // corresponding to fields: 'x', 'y', 'z', 'cool', 'name',
    // defined in schema
    structSize=5,

    // offsets
	xOffset=0, // typeof number
	yOffset=1, // typeof number
	zOffset=2, // typeof number
	coolOffset=3, // typeof StructBool
	nameOffset=4, // typeof Char
}

const enum conversions {
    byteToFloat64Factor=4
}

export interface ExampleObject {
	x: number
	y: number
	z: number
	cool: StructBool
	name: Char
}

export class Example implements ArrayOfStruct<ExampleObject> {
    // these are here for sanity checks.
    // not compiled away by typescript.
    // also not used at runtime.
    // can be used as debugging tool
    static readonly structSize = ExampleEncoding.structSize
	static readonly xOffset=ExampleEncoding.xOffset
	static readonly yOffset=ExampleEncoding.yOffset
	static readonly zOffset=ExampleEncoding.zOffset
	static readonly coolOffset=ExampleEncoding.coolOffset
	static readonly nameOffset=ExampleEncoding.nameOffset
    
    static fromBuffer(buffer: ArrayBuffer | SharedArrayBuffer): Example {
        try {
            const array = new Float64Array(buffer)
            return Example.fromFloat64Array(array)
        } catch {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input buffer was not an array of struct. Encoding is incorrect")
        }
    }

    static fromFloat64Array(array: Float64Array): Example {
        const isCorrectlyEncoded = isStructArray(array)
        if (!isCorrectlyEncoded) {
            throw new Error("(STURCT_CONSTRUCTOR_ERROR): input array was not an array of struct. Encoding is incorrect")
        }
        const structArray = new Example(0, false, true)
        structArray.setMemory(array)
        return structArray
    }

    private memory: Float64Array
    
    constructor(initialSize: number, shared: boolean, fromPayload: boolean) {
        if (fromPayload) {
            this.memory = new Float64Array()
        } else {
            const requestedMemorySize = fastAbsoluteValue(initialSize)
            const sizeOfOneStructInBytes = (ExampleEncoding.structSize * conversions.byteToFloat64Factor) + (StructEncoding.encodingReservedIndicesCount * conversions.byteToFloat64Factor)
            const BufferClass = shared ? SharedArrayBuffer : ArrayBuffer
            const buffer = new BufferClass(sizeOfOneStructInBytes * requestedMemorySize)
            const memory = new Float64Array(buffer)
            
            // set encoding information
            memory[StructEncoding.encodingPaddingOneIndex] = StructEncoding.encodingPaddingOneValue
            memory[StructEncoding.encodingPaddingTwoIndex] = StructEncoding.encodingPaddingTwoValue
            memory[StructEncoding.structSizeIndex] = ExampleEncoding.structSize
            // end
            
            this.memory = memory
        }
    }
    
    // returns underlying memory for array
    getMemory(): Float64Array {
        return this.memory
    }

    // sets underlying memory of array from a TypedArray
    // WARNING: this is an unsafe operation. Make sure the typed
    // array you are using to overwrite with is a StructArray by 
    // using the "isStructArray" utility function.
    setMemory(newMemory: Float64Array) {
        this.memory = newMemory
    }

    // number of structs in array is stored in this array
    // check compiler primitives for reference.
    length(): number {
        return this.memory[StructEncoding.lengthIndex] || StructEncoding.encodingInformationMissing
    }

    // returns number of elements that can be added before
    // resize is needed
    capacity(): number {
        const rawMemory = this.memory.length - StructEncoding.encodingReservedIndicesCount
        return rawMemory / ExampleEncoding.structSize
    }

    /* array mutators */

    // sets a given index in array with inputted values
    // note: inputting an index greater than the length of array has no effect
    set(index: number, x: number, y: number, z: number, cool: StructBool, name: Char,) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.xOffset] = x
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.yOffset] = y
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.zOffset] = z
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.coolOffset] = cool
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.nameOffset] = name.charCodeAt(0)
    }

    // sets a given index in array with inputted values in an unsafe manner
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    // note: inputting an index greater than the length of array has no effect
    unsafeSet(index: number, x: number, y: number, z: number, cool: StructBool, name: Char,) {
        const indexOffset = index * ExampleEncoding.structSize
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.xOffset] = x
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.yOffset] = y
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.zOffset] = z
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.coolOffset] = cool
		this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.nameOffset] = name.charCodeAt(0)
    }

    // removes a given index from array
    // note: do not use if order of array matters
    // this method swaps last element and target element
    // then pops the last element. This is far more performant
    // than the typical array.splice
    // Also: if you want the element back
    // you must do this manually.
    splice(index: number) {
        const lastIndex = this.length() - 1
        // make sure operation is valid
        if (index > lastIndex) {
            return
        }
        if (lastIndex === index) {
            return this.pop()
        }
        // create temporary variables with last element's values
		const xTmp = this.xGet(lastIndex)
		const yTmp = this.yGet(lastIndex)
		const zTmp = this.zGet(lastIndex)
		const coolTmp = this.coolGet(lastIndex)
		const nameTmp = this.nameGet(lastIndex)
        
        // swap last element with target index
        const safeIndex = fastAbsoluteValue(index)
        this.unsafeSet(lastIndex, this.xGet(safeIndex), this.yGet(safeIndex), this.zGet(safeIndex), this.coolGet(safeIndex), this.nameGet(safeIndex),)
        this.unsafeSet(safeIndex, xTmp, yTmp, zTmp, coolTmp, nameTmp,)
        
        // now that target index is in last index, remove it
        this.pop()
    }

    // adds inputted struct at end of the array
    push(x: number, y: number, z: number, cool: StructBool, name: Char,) {
        const index = this.length() * ExampleEncoding.structSize
		this.memory[StructEncoding.encodingReservedIndicesCount + index + ExampleEncoding.xOffset] = x
		this.memory[StructEncoding.encodingReservedIndicesCount + index + ExampleEncoding.yOffset] = y
		this.memory[StructEncoding.encodingReservedIndicesCount + index + ExampleEncoding.zOffset] = z
		this.memory[StructEncoding.encodingReservedIndicesCount + index + ExampleEncoding.coolOffset] = cool
		this.memory[StructEncoding.encodingReservedIndicesCount + index + ExampleEncoding.nameOffset] = name.charCodeAt(0)        
        
        // increment length count
        this.memory[StructEncoding.lengthIndex]++
    }

    // removes the last element of array
    // note: if you want the element back
    // you must do this manually.
    pop() {
        if (this.length() < 1) {
            return
        }
        // decrement length count
        this.memory[StructEncoding.lengthIndex]--
    }
    /* array mutators end */

    /* struct property setters and getters */

    // a getter method for 'x' property
    xGet(index: number): number {
        const indexOffset = index * ExampleEncoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.xOffset]
        return value as number
    }

    // a setter method for 'x' property
    xSet(index: number, value: number) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.xOffset] = value
    }

    // an unsafe setter method for 'x' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    xUnsafeSet(index: number, value: number) {
        const indexOffset = index * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.xOffset] = value
    }

    // a getter method for 'y' property
    yGet(index: number): number {
        const indexOffset = index * ExampleEncoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.yOffset]
        return value as number
    }

    // a setter method for 'y' property
    ySet(index: number, value: number) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.yOffset] = value
    }

    // an unsafe setter method for 'y' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    yUnsafeSet(index: number, value: number) {
        const indexOffset = index * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.yOffset] = value
    }

    // a getter method for 'z' property
    zGet(index: number): number {
        const indexOffset = index * ExampleEncoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.zOffset]
        return value as number
    }

    // a setter method for 'z' property
    zSet(index: number, value: number) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.zOffset] = value
    }

    // an unsafe setter method for 'z' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    zUnsafeSet(index: number, value: number) {
        const indexOffset = index * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.zOffset] = value
    }

    // a getter method for 'cool' property
    coolGet(index: number): StructBool {
        const indexOffset = index * ExampleEncoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.coolOffset]
        return value as StructBool
    }

    // a setter method for 'cool' property
    coolSet(index: number, value: StructBool) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.coolOffset] = value
    }

    // an unsafe setter method for 'cool' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    coolUnsafeSet(index: number, value: StructBool) {
        const indexOffset = index * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.coolOffset] = value
    }

    // a getter method for 'name' property
    nameGet(index: number): Char {
        const indexOffset = index * ExampleEncoding.structSize
        const value = this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.nameOffset]
        return String.fromCharCode(value) as Char
    }

    // a setter method for 'name' property
    nameSet(index: number, value: Char) {
        const safeIndex = fastAbsoluteValue(index)
        const indexOffset = safeIndex * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.nameOffset] = value.charCodeAt(0)
    }

    // an unsafe setter method for 'name' property
    // WARNING: inputting a negative index may result in 
    // memory corruption. Please make sure that an inputted
    // index is non-negative by using the "fastAbsoluteValue" utility function.
    nameUnsafeSet(index: number, value: Char) {
        const indexOffset = index * ExampleEncoding.structSize
        this.memory[StructEncoding.encodingReservedIndicesCount + indexOffset + ExampleEncoding.nameOffset] = value.charCodeAt(0)
    }

    // return a given index as a TypedArray
    indexAsArray(index: number): Float64Array {
        const indexOffset = index * ExampleEncoding.structSize
        const startIndex = StructEncoding.encodingReservedIndicesCount + indexOffset
        return this.memory.slice(startIndex, startIndex + ExampleEncoding.structSize)
    }
    /* struct property setters and getters end */

    /* debugging tools */

    // return a given index as a JS object
    indexAsObject(index: number): ExampleObject {
        return {
			x: this.xGet(index),
			y: this.yGet(index),
			z: this.zGet(index),
			cool: this.coolGet(index),
			name: this.nameGet(index),
        }
    }

    // a runtime check to verify that memory
    // hasn't been corrupted
    isStructArray(): boolean {
        return isStructArray(this.memory)
    }

    // the number of indices an individual struct takes in memory
    // check compiler primitives for reference.
    structSize(): number {
        return this.memory[StructEncoding.structSizeIndex] || StructEncoding.encodingInformationMissing
    }
    /* debugging tools end */
}
/* struct compiler end */